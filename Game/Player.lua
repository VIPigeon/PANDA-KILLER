--[[

–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ –¥–∂—É–Ω–≥–ª–∏! üå¥üêí

–ù–∏–∂–µ –Ω–∞—Ö–æ–¥–∏—Ç—Å—è –ø–æ–ª–æ—Ç–Ω–æ –∫–æ–¥–∞, –∫–æ—Ç–æ—Ä–æ–µ —Ç–∏—Ä–∞–Ω–∏—á–µ—Å–∫–∏ —É–ø—Ä–∞–≤–ª—è–µ—Ç –∏–≥—Ä–æ–∫–æ–º. –ü—Ä–∞–∫—Ç–∏—á–µ—Å–∫–∏
–≤—Å—è –ª–æ–≥–∏–∫–∞ –ª–µ–∂–∏—Ç –≤ player.update(). –ê —á—Ç–æ? –î—É–º–∞–µ—Ç–µ —ç—Ç–æ –Ω–µ –∫—Ä—É—Ç–æ(–≤–æ–æ–±—â–µ-—Ç–æ –¥–∞ << Nerd), —á—Ç–æ —É –º–µ–Ω—è –±–æ–ª—å—à–∞—è
—Ñ—É–Ω–∫—Ü–∏—è, –∫–æ—Ç–æ—Ä–∞—è –±—É–¥–µ—Ç —Ä–∞—Å—Ç–∏ –µ—â—ë –±–æ–ª—å—à–µ –≤ –±—É–¥—É—â–µ–º? –í–æ—Ç —á—Ç–æ –î–∂–æ–Ω –ö–∞—Ä–º–∞–∫ (ü§Ø) —Å–∫–∞–∑–∞–ª
–±—ã –≤–∞–º: https://cbarrete.com/carmack.html

–ù–µ –∑–Ω–∞–µ—Ç–µ –∫—Ç–æ —Ç–∞–∫–æ–π –î–∂–æ–Ω –ö–∞—Ä–º–∞–∫? –ü–æ–∑–æ—Ä. –ù–µ, —Ä–µ–∞–ª—å–Ω–æ, –ø–æ—Å–º–æ—Ç—Ä–∏—Ç–µ –∫—Ç–æ —ç—Ç–æ ü§¨.
–ò —Å—Ç–∞—Ç—å—é –ø—Ä–æ—á–∏—Ç–∞–π—Ç–µ.

–ù–µ –≤–µ—Ä–∏—Ç–µ —ç—Ç–æ–º—É —Å—Ç–∞—Ä–∏—á–∫—É? –¢–æ–≥–¥–∞ –±–æ–ª–µ–µ —Ä–µ–∞–ª—å–Ω—ã–π –ø—Ä–∏–º–µ—Ä: –∫–ª–∞—Å—Å –∏–≥—Ä–æ–∫–∞ –∏–∑ Celeste üçì,
–ø–ª–∞—Ç—Ñ–æ—Ä–º–µ—Ä–∞ —Å, –ø–æ–∂–∞–ª—É–π, —Å–∞–º—ã–º –ª—É—á—à–∏–º —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –∫–æ–≥–¥–∞ –ª–∏–±–æ —Å–¥–µ–ª–∞–Ω–Ω—ã–º. –û–Ω –µ—Å—Ç—å
–≤ –æ—Ç–∫—Ä—ã—Ç–æ–º –¥–æ—Å—Ç—É–ø–µ: https://github.com/NoelFB/Celeste/blob/master/Source/Player/Player.cs
–í —ç—Ç–æ–º –º–æ–Ω–æ–ª–∏—Ç–µ 5000 —Å—Ç—Ä–æ–∫ –∫–æ–¥–∞. –ò –æ–Ω–∏ —Ä–∞–±–æ—Ç–∞—é—Ç –±–µ–∑—É–ø—Ä–µ—á–Ω–æ. –í–æ—Ç —Ç–∞–∫!

–†–µ—Ñ–µ—Ä–µ–Ω—Å –¥–ª—è —Ñ–∏–∑–∏–∫–∏ –∏–≥—Ä–æ–∫–∞: https://2dengine.com/doc/platformers.html
–ö—Ä—É—Ç–æ–π –≤–∏–¥–æ—Å –ø—Ä–æ Celeste: https://www.youtube.com/watch?v=yorTG9at90g

–õ–ò–¶–ï–ù–ó–ò–Ø: –ò—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å —ç—Ç–æ—Ç –∫–æ–¥ –≤ –∫–æ–º–º–µ—Ä—á–µ—Å–∫–∏—Ö —Ü–µ–ª—è—Ö –ó–ê–ü–†–ï–©–ï–ù–û.
–ï—Å–ª–∏ –æ—á–µ–Ω—å —Ö–æ—á–µ—Ç—Å—è, —Ç–æ –Ω—É–∂–Ω–æ –∑–∞–ø–ª–∞—Ç–∏—Ç—å –º–Ω–µ $10. (c) –∫–∞–≤–∞–π–Ω—ã–π-–∫–æ–¥

--]]

Player = {}

function Player:new(x, y)
    local object = {
        x = PLAYER_SPAWNPOINT_X,
        y = PLAYER_SPAWNPOINT_Y,
        velocity = {
            x = 0,
            y = 0,
        },
        hitbox = Hitbox:new(6, 0, 4, 8),
        physics_settings = {
            gravity = PLAYER_GRAVITY,
            friction = PLAYER_FRICTION,
            min_horizontal_velocity = PLAYER_MIN_HORIZONTAL_VELOCITY,
        },

        sprite = PLAYER_SPRITE_IDLE,

        -- –ö–æ–≥–¥–∞ –∏–≥—Ä–æ–∫ —É–º–∏—Ä–∞–µ—Ç, —É –Ω–µ–≥–æ —Å–ª–µ—Ç–∞–µ—Ç —à–ª—è–ø–∞
        hat = nil,

        attack_rects = {},
        attack_effect = nil,
        attack_effect_time = 0,

        stuck_to_left_wall = false,
        stuck_to_right_wall = false,
        looking_left = false,
        was_on_ground_last_frame = false,
        was_sliding_on_wall_last_frame = false,
        is_dead = false,

        -- –≠—Ç–æ –¥–ª—è –∞–Ω–∏–º–∞—Ü–∏–π. –ö–∞–∫ –ø–æ –¥—Ä—É–≥–æ–º—É, —è –Ω–µ –ø—Ä–∏–¥—É–º–∞–ª üòú
        has_attacked_in_air = false,
        has_attacked_downward = false,
        has_attacked_upwards = false,
        just_attacked = false,

        coyote_time = 0.0,
        attack_timer = 0.0,
        jump_buffer_time = 0.0,
        remove_horizontal_speed_limit_time = 0.0,
        attack_buffer_time = 0.0,
        time_we_have_been_running = 0.0,

        time_before_showing_death_screen = 0.0,
    }

    setmetatable(object, self)
    return object
end

function Player:die(kill_velocity_x, kill_velocity_y)
    if self.is_dead then
        return
    end

    self.velocity.x = PLAYER_DEATH_KNOCKBACK_HORIZONTAL * math.sign(kill_velocity_x)
    self.velocity.y = PLAYER_DEATH_KNOCKBACK_VERTICAL

    self.time_before_showing_death_screen = PLAYER_TIME_BEFORE_SHOWING_DEATH_SCREEN_AFTER_DEATH
    self.is_dead = true

    self.attack_effect_time = 0
    self.hat = Hat:new(self.x, self.y, 0.5 * self.velocity.x + kill_velocity_x, 0.5 * self.velocity.y + kill_velocity_y)

    Basic.play_sound(SOUNDS.PLAYER_DEAD)
end

function Player:update()
    if self.is_dead then
        Physics.update(self)
        self.hat:update()

        self.sprite = PLAYER_SPRITE_DEAD
        self.time_before_showing_death_screen = Basic.tick_timer(self.time_before_showing_death_screen)
        if self.time_before_showing_death_screen == 0.0 then
            game.dialog_window.is_closed = false
            game.state = GAME_STATE_PAUSED
            self.x = PLAYER_SPAWNPOINT_X
            self.y = PLAYER_SPAWNPOINT_Y
            self.velocity.x = 0
            self.velocity.y = 0
        end

        return
    end

    -- –ö—Ä–∞—Ç–∫–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ update() üì∞
    --
    -- 1. –ù–∞ –Ω–∞—á–∞–ª–µ –∫–∞–¥—Ä–∞ –¥–µ–ª–∞–µ–º –Ω–µ—Å–∫–æ–ª—å–∫–æ "–∑–∞–ø—Ä–æ—Å–æ–≤" –∫ —Ñ–∏–∑–∏–∫–µ, —á—Ç–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å
    --    –∫–∞–∫–∏–µ —Å—Ç–µ–Ω—ã —Ä—è–¥–æ–º —Å –Ω–∞–º–∏, –Ω–∞ –∑–µ–º–ª–µ –ª–∏ –º—ã, —Ç.–¥.
    --
    -- 2. –°—á–∏—Ç—ã–≤–∞–µ–º –≤–≤–æ–¥ –∏–≥—Ä–æ–∫–∞ –∏ –ø—Ä–µ–æ–±—Ä–∞–∑—É–µ–º –µ–≥–æ –≤ "—Ñ–∏–∑–∏—á–µ—Å–∫–∏–µ —Å–∏–ª—ã", —á—Ç–æ
    --    –¥–µ–π—Å—Ç–≤—É—é—Ç –Ω–∞ –∏–≥—Ä–æ–∫–∞.  –ù–∞–ø—Ä–∏–º–µ—Ä, –µ—Å–ª–∏ –º—ã –Ω–∞–∂–∏–º–∞–µ–º RIGHT, —Ç–æ –Ω–∞ –∏–≥—Ä–æ–∫–∞
    --    –ø–æ–¥–µ–π—Å—Ç–≤—É–µ—Ç —É—Å–∫–æ—Ä–µ–Ω–∏–µ(!) –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–Ω–æ–µ –Ω–∞–ø—Ä–∞–≤–æ. –§–∞–∫—Ç–∏—á–µ—Å–∫–∏ –∑–¥–µ—Å—å –º—ã
    --    –æ–ø—Ä–µ–¥–µ–ª—è–µ–º player.velocity
    --
    -- 3. –ü—ã—Ç–∞–µ–º—Å—è –ø—Ä–∏–º–µ–Ω–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è –≤ –ø–æ–∑–∏—Ü–∏–∏ (next_x, next_y). –û–¥–Ω–∞–∫–æ
    --    —Ä–µ–∞–ª—å–Ω—ã–π –º–∏—Ä –∑–∞–±–∏—Ä–∞–µ—Ç –Ω–∞—à—É —Å–≤–æ–±–æ–¥—É üóΩ‚ùå! –ù—É–∂–Ω–æ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å, —á—Ç–æ –º—ã –Ω–µ
    --    —Å—Ç–æ–ª–∫–Ω—É–ª–∏—Å—å –Ω–∏ —Å —á–µ–º. –ê –µ—Å–ª–∏ —Å—Ç–æ–ª–∫–Ω—É–ª–∏—Å—å, —Ç–æ –Ω—É–∂–Ω–æ –ø–æ—Å—Ç–∞–≤–∏—Ç—å –∏–≥—Ä–æ–∫–∞
    --    –Ω–∞—Å—Ç–æ–ª—å–∫–æ –±–ª–∏–∑–∫–æ –∫ –º–µ—Å—Ç—É –∫ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏—é, –Ω–∞—Å–∫–æ–ª—å–∫–æ –≤–æ–∑–º–æ–∂–Ω–æ. –î—Ä—É–≥–∏–º–∏
    --    —Å–ª–æ–≤–∞–º–∏, –µ—Å–ª–∏ (2) —Å—Ç–∞–≤–∏—Ç player.velocity, —Ç–æ (3) —Å—Ç–∞–≤–∏—Ç player.x, player.y.
    --    –Ø –Ω–µ –æ—á–µ–Ω—å —Ö–æ—Ä–æ—à–æ –æ–±—ä—è—Å–Ω—è—é, –º–Ω–µ –Ω–∞–¥–æ–µ–ª–æ –ø–∏—Å–∞—Ç—å –∫–æ–º–º–µ–Ω—Ç—ã. –ß–∏—Ç–∞–π—Ç–µ –∫–æ–¥ —Å–∞–º–∏ üò°!
    --


    -- 1. –ó–∞–ø—Ä–æ—Å—ã. –ù–∏—á–µ–≥–æ –∏–Ω—Ç–µ—Ä–µ—Å–Ω–æ–≥–æ
    local is_on_ground = Physics.is_on_ground(self)

    local collision_to_the_left = Physics.check_collision_rect_tilemap(self.hitbox:to_rect(self.x - 1, self.y))
    local hugging_left_wall = collision_to_the_left ~= nil

    local collision_to_the_right = Physics.check_collision_rect_tilemap(self.hitbox:to_rect(self.x + 1, self.y))
    local hugging_right_wall = collision_to_the_right ~= nil

    local player_rect = Hitbox.rect_of(self)

    -- –ø—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –∫–æ–ª–∏–∑–∏—é –ø–ª–æ—Ö–æ–≥–æ —Ç–∞–π–ª–∞ –∏ –∏–∑–º–µ–Ω–µ–Ω–∏–µ is_dead
    --
    -- ‚ö†  –í–Ω–∏–º–∞–Ω–∏–µ ‚ö†
    -- –≠—Ç–æ—Ç –∫–æ–¥ —Å –ø–ª–æ—Ö–∏–º–∏ —Ç–∞–π–ª–∞–º–∏ –Ω–µ –º–æ–π. –¢–∞–∫ —á—Ç–æ –Ω–µ –∂–∞–ª—É–π—Ç–µ—Å—å –Ω–∞ –Ω–µ–≥–æ! üò†
    --
    local tiles_that_we_collide_with = Physics.tile_ids_that_intersect_with_rect(self.hitbox:to_rect(self.x,self.y))
    for _, collision in ipairs(tiles_that_we_collide_with) do
        for _, bad_tile in pairs(data.bad_tile) do
            if collision.id == bad_tile then
                self:die()
                return
            end
        end
    end

    -- 2. –°—á–∏—Ç—ã–≤–∞–µ–º –≤–≤–æ–¥, —Ä–∞–±–æ—Ç–∞–µ–º —Ç–æ–ª—å–∫–æ —Å self.velocity
    local walking_right = btn(BUTTON_RIGHT) or key(KEY_D)
    local walking_left = btn(BUTTON_LEFT) or key(KEY_A)
    local looking_down = btn(BUTTON_DOWN) or key(KEY_S)
    local looking_up = btn(BUTTON_UP) or key(KEY_W)
    local jump_pressed = btnp(BUTTON_Z) or keyp(KEY_W)
    local attack_pressed = btnp(BUTTON_X)

    if jump_pressed then
      self.jump_buffer_time = PLAYER_JUMP_BUFFER_TIME
    end

    if attack_pressed then
        self.attack_buffer_time = PLAYER_ATTACK_BUFFER_TIME

        if not is_on_ground then
            self.has_attacked_in_air = true
        else
            self.has_attacked_in_air = false
        end

        self.has_attacked_downward = false
        self.has_attacked_upwards = false
        if looking_down then
            self.has_attacked_downward = true
        elseif looking_up then
            self.has_attacked_upwards = true
        end
    end

    if self.attack_timer == 0 then
        self.just_attacked = false
        self.attack_rects = {}
        if self.attack_buffer_time > 0.0 then
            self.sprite:reset()
            self.attack_timer = PLAYER_ATTACK_DURATION
            self.attack_buffer_time = 0.0
            Basic.play_sound(SOUNDS.PLAYER_ATTACK)
        end
    end

    if self.attack_timer > 0 and
       table.contains(PLAYER_ATTACK_SPRITES, self.sprite) and
       self.sprite:animation_ended()
    then
        --
        -- side note:
        -- –¢–æ—á–Ω–æ –ª–∏ –∞—Ç–∞–∫–∏ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ - —Ö–æ—Ä–æ—à–∞—è –∏–¥–µ—è?
        local attack_direction_x = 0
        local attack_direction_y = 0
        if looking_down then
            attack_direction_y = attack_direction_y + 1
        elseif looking_up then
            attack_direction_y = attack_direction_y - 1
        else
            if self.looking_left then
                attack_direction_x = attack_direction_x - 1
            else
                attack_direction_x = attack_direction_x + 1
            end
        end

        -- –ò–∑-–∑–∞ –≤–æ—Ç —Ç–∞–∫–æ–π —à—Ç—É–∫–∏ –∞—Ç–∞–∫–∏ –ø–æ –¥–∏–∞–≥–æ–Ω–∞–ª–∏ –¥–æ–≤–æ–ª—å–Ω–æ –∏–º–±–æ–≤—ã–µ. –ê —á—Ç–æ –¥–µ–ª–∞—Ç—å?
        local attack_width = 8 + 2 * math.abs(attack_direction_x)
        local attack_height = 8 + 2 * math.abs(attack_direction_y)
        local attack_x = player_rect:center_x() - attack_width / 2 + attack_direction_x * 8
        local attack_y = player_rect:center_y() - attack_height / 2 + attack_direction_y * 8
        local attack_rect = Rect:new(attack_x, attack_y, attack_width, attack_height)

        local attack_tilemap_collision = Physics.check_collision_rect_tilemap(attack_rect)

        -- –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ ü§Æ
        self.attack_rects = {attack_rect, player_rect}

        hit_pandas = {}
        for _, panda in ipairs(game.pandas) do
            local panda_rect = Hitbox.rect_of(panda)
            for _, attack_rect in ipairs(self.attack_rects) do
                if Physics.check_collision_rect_rect(attack_rect, panda_rect) then
                    table.insert(hit_pandas, panda)
                    break
                end
            end
        end
        if #hit_pandas > 0 then
            if looking_down then
                self.velocity.y = PLAYER_JUMP_STRENGTH
            end

            for _, panda in ipairs(hit_pandas) do
                panda:take_damage(attack_direction_x, attack_direction_y)
            end
            self.attack_timer = 0
        end

        if not self.just_attacked then
            self.just_attacked = true
            if self.has_attacked_downward then
                self.attack_effect = ChildBody:new(self, 8 * attack_direction_x, 8 * attack_direction_y, PLAYER_SPRITE_ATTACK_PARTICLE_EFFECT_DOWNWARD)
            elseif self.has_attacked_upwards then
                self.attack_effect = ChildBody:new(self, 0, -16, PLAYER_SPRITE_ATTACK_PARTICLE_EFFECT_UPWARD)
            else
                local flip = (attack_direction_x < 0) and 1 or 0
                self.attack_effect = ChildBody:new(self, 8 * attack_direction_x, -8 + 8 * attack_direction_y, PLAYER_SPRITE_ATTACK_PARTICLE_EFFECT_HORIZONTAL, flip)
            end
            self.attack_effect_time = PLAYER_ATTACK_EFFECT_DURATION
        end

        game.camera:shake(PLAYER_ATTACK_SHAKE_MAGNITUDE, PLAYER_ATTACK_SHAKE_DURATION)
    end

    if not moving_right and not moving_left then
        if is_on_ground then
            self.velocity.x = self.velocity.x - self.velocity.x * PLAYER_FRICTION * Time.dt()
        else
            -- –¢–∏–ø–∞ –≤ –≤–æ–∑–¥—É—Ö–µ –¥—Ä—É–≥–æ–µ —Å–æ–ø—Ä–æ—Ç–∏–≤–ª–µ–Ω–∏–µ üí®
            -- –ù–µ –∑–Ω–∞—é, –Ω–∞ —Å–∫–æ–ª—å–∫–æ —ç—Ç–æ –Ω—É–∂–Ω–æ üòÖ
            self.velocity.x = self.velocity.x - self.velocity.x * PLAYER_AIR_FRICTION * Time.dt()
        end
    end
    local not_at_speed_limit = math.abs(self.velocity.x) < PLAYER_MAX_HORIZONTAL_SPEED
    if not_at_speed_limit then
        if walking_right then
            if math.abs(self.velocity.x) < PLAYER_MAX_HORIZONTAL_SPEED then
                self.velocity.x = self.velocity.x + PLAYER_HORIZONTAL_ACCELERATION * Time.dt()
            end
        end
        if walking_left then
            if math.abs(self.velocity.x) < PLAYER_MAX_HORIZONTAL_SPEED then
                self.velocity.x = self.velocity.x - PLAYER_HORIZONTAL_ACCELERATION * Time.dt()
            end
        end
        self.velocity.x = math.clamp(self.velocity.x, -PLAYER_MAX_HORIZONTAL_SPEED, PLAYER_MAX_HORIZONTAL_SPEED)
    end

    if not is_on_ground then
        if self.remove_horizontal_speed_limit_time == 0.0 then
            self.velocity.y = self.velocity.y - PLAYER_GRAVITY * Time.dt()
        else
            self.velocity.y = self.velocity.y - PLAYER_GRAVITY_AFTER_WALL_JUMP * Time.dt()
        end
    end

    local has_jumped = false
    local has_walljumped = false
    local should_jump = self.jump_buffer_time > 0.0
    if should_jump then
        if is_on_ground and self.velocity.y <= 0 then
            self.velocity.y = PLAYER_JUMP_STRENGTH
            has_jumped = true
        elseif hugging_left_wall and not is_on_ground then
            self.velocity.y = PLAYER_WALL_JUMP_VERTICAL_STRENGTH
            self.velocity.x = PLAYER_WALL_JUMP_HORIZONTAL_STRENGTH
            self.remove_horizontal_speed_limit_time = PLAYER_REMOVE_SPEED_LIMIT_AFTER_WALL_JUMP_TIME
            has_jumped = true
            has_walljumped = true
        elseif hugging_right_wall and not is_on_ground then
            self.velocity.y = PLAYER_WALL_JUMP_VERTICAL_STRENGTH
            self.velocity.x = -1 * PLAYER_WALL_JUMP_HORIZONTAL_STRENGTH
            self.remove_horizontal_speed_limit_time = PLAYER_REMOVE_SPEED_LIMIT_AFTER_WALL_JUMP_TIME
            has_jumped = true
            has_walljumped = true
        end
    end
    if jump_pressed and self.coyote_time > 0.0 and self.velocity.y <= 0.0 then
        self.velocity.y = PLAYER_JUMP_STRENGTH
        has_jumped = true
    end
    if has_jumped then
        self.coyote_time = 0.0
        self.jump_buffer_time = 0.0
        Basic.play_sound(SOUNDS.PLAYER_JUMP)
    end

    if is_on_ground and not self.was_on_ground_last_frame then
        Effects.add(self.x, self.y, PLAYER_SPRITE_LAND_PARTICLE_EFFECT)
    end

    if not is_on_ground and self.was_on_ground_last_frame and self.velocity.y <= 0 then
       self.coyote_time = PLAYER_COYOTE_TIME
    end
    self.was_on_ground_last_frame = is_on_ground

    local can_stick_to_wall = self.velocity.y <= 0
    local sliding_on_wall = false
    if not is_on_ground and can_stick_to_wall then
        if hugging_left_wall and self.velocity.x < 0 or
           hugging_right_wall and self.velocity.x > 0 then
            self.velocity.y = -1 * PLAYER_WALL_SLIDE_SPEED
            sliding_on_wall = true
        end
    end
    if self.was_sliding_on_wall_last_frame and not sliding_on_wall then
        Basic.play_sound(SOUNDS.MUTE_CHANNEL_ONE)
    elseif not self.was_sliding_on_wall_last_frame and sliding_on_wall then
        Basic.play_sound(SOUNDS.PLAYER_SLIDE)
        sfx(8, 'D-1', -1, 1)
    end
    self.was_sliding_on_wall_last_frame = sliding_on_wall


    if math.abs(self.velocity.x) < PLAYER_MIN_HORIZONTAL_VELOCITY then
        self.velocity.x = 0
    end
    if math.abs(self.velocity.y) < PLAYER_MIN_VERTICAL_VELOCITY then
        self.velocity.y = 0
    end

    self.velocity.y = math.clamp(self.velocity.y, -PLAYER_MAX_FALL_SPEED, PLAYER_MAX_FALL_SPEED)

    local moving_right = self.velocity.x > 0
    local moving_left  = self.velocity.x < 0
    if moving_right then
        self.looking_left = false
    elseif moving_left then
        self.looking_left = true
    end


    -- 3. –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π. –£–∂–µ –Ω–µ —Ç–∞–∫ –≤–ø–µ—á–∞—Ç–ª—è—é—â–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ —è –≤—ã–Ω–µ—Å –∫–æ–¥ –≤ Physics
    local horizontal_collision = Physics.move_x(self)
    if horizontal_collision ~= nil then
        self.velocity.x = 0
    end

    local vertical_collision = Physics.move_y(self)
    if vertical_collision ~= nil then
        self.velocity.y = 0
    end

    -- –ê–Ω–∏–º–∞—Ü–∏—è–º–∏ –∑–∞–Ω–∏–º–∞—é—Ç—Å—è –∑–¥–µ—Å—å üè≠
    -- –ó–∞–º–µ—Ç–∫–∞ –¥–ª—è –º–µ–Ω—è –∏–∑ –±—É–¥—É—â–µ–≥–æ:
    -- –ó–¥–µ—Å—å –º–æ–∂–µ—Ç –±—ã—Ç—å –±–∞–≥ —Å —Ç–µ–º, —á—Ç–æ —Å–ø—Ä–∞–π—Ç—ã –≥–ª–æ–±–∞–ª—å–Ω—ã–µ. –¢–∞–∫ –±—ã–ª–æ
    -- –≤ –ø–∞–Ω–¥–∞—Ö, —É –∫–æ—Ç–æ—Ä—ã—Ö –±—ã–ª –æ–¥–∏–Ω –æ–±—â–∏–π —Å–ø—Ä–∞–π—Ç –Ω–∞ –≤—Å–µ—Ö, –ø–æ—ç—Ç–æ–º—É –ø—Ä–∏—à–ª–æ—Å—å
    -- –∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å.
    if has_jumped then
        if has_walljumped then
            -- –ù–∞–≤–µ—Ä–Ω–æ–µ –≤ –±—É–¥—É—â–µ–º –∑–¥–µ—Å—å –≤–æ–æ–±—â–µ –±—É–¥—É—Ç –∫–∞—Å—Ç–æ–º–Ω—ã–µ —ç—Ñ—Ñ–µ–∫—Ç—ã. –ü–æ–∫–∞
            -- —á—Ç–æ –∂–µ —Ç—É—Ç –º–∞–≥–∏—á–µ—Å–∫–∏–µ –∫–æ–Ω—Å—Ç–∞–Ω—Ç—ã ü™Ñ
            if self.looking_left then
                Effects.add(self.x + 2, self.y, PLAYER_SPRITE_JUMP_PARTICLE_EFFECT)
            else
                Effects.add(self.x + 1, self.y, PLAYER_SPRITE_JUMP_PARTICLE_EFFECT)
            end
        else
            Effects.add(self.x, self.y, PLAYER_SPRITE_JUMP_PARTICLE_EFFECT)
        end
    end

    local previous_sprite = self.sprite

    if self.sprite == PLAYER_SPRITE_ATTACK and not self.sprite:animation_ended() then
        -- goto –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω üòé
        goto no_sprite_change
    end

    if self.attack_timer > 0 then
        if self.has_attacked_downward then
            self.sprite = PLAYER_SPRITE_ATTACK_AIR_DOWNWARD
        elseif self.has_attacked_upwards then
            self.sprite = PLAYER_SPRITE_ATTACK_UPWARDS
        elseif self.has_attacked_in_air then
            self.sprite = PLAYER_SPRITE_ATTACK_AIR_FORWARD
        else
            self.sprite = PLAYER_SPRITE_ATTACK
        end
    elseif sliding_on_wall then
        self.sprite = PLAYER_SPRITE_SLIDE
    elseif self.velocity.y < 0 and not is_on_ground then
        self.sprite = PLAYER_SPRITE_FALLING
    elseif self.velocity.y ~= 0 or not is_on_ground then
        self.sprite = PLAYER_SPRITE_JUMP
    elseif self.time_we_have_been_running > 0.1 and self.velocity.x ~= 0 then
        self.sprite = PLAYER_SPRITE_RUNNING
    else
        self.sprite = PLAYER_SPRITE_IDLE
    end

    if self.sprite ~= previous_sprite then
        self.sprite:reset()
    end

    ::no_sprite_change::

    -- –£ –∏–≥—Ä–æ–∫–∞ –µ—Å—Ç—å –º–Ω–æ–≥–æ –≤–µ—â–µ–π, –∑–∞–≤–∏—Å—è—â–∏—Ö –æ—Ç –≤—Ä–µ–º–µ–Ω–∏ (—Ç–∞–π–º–µ—Ä–æ–≤).
    -- –û–Ω–∏ –æ–±–Ω–æ–≤–ª—è—é—Ç—Å—è —Ç—É—Ç, –≤ —Å–∞–º–æ–º –∫–æ–Ω—Ü–µ.
    self.jump_buffer_time = Basic.tick_timer(self.jump_buffer_time)
    self.coyote_time = Basic.tick_timer(self.coyote_time)
    self.remove_horizontal_speed_limit_time = Basic.tick_timer(self.remove_horizontal_speed_limit_time)
    self.attack_timer = Basic.tick_timer(self.attack_timer)
    self.attack_buffer_time = Basic.tick_timer(self.attack_buffer_time)
    self.attack_effect_time = Basic.tick_timer(self.attack_effect_time)
    if self.velocity.x ~= 0 then
        self.time_we_have_been_running = self.time_we_have_been_running + Time.dt()
    else
        self.time_we_have_been_running = 0
    end
end

function Player:draw()
    local colorkey = 0
    local scale = 1

    local flip = self.looking_left and 1 or 0

    local tx, ty = game.camera:transform_coordinates(self.x, self.y)
    ty = ty - 8 * (self.sprite:current_animation().height - 1)

    for _, attack_rect in ipairs(self.attack_rects) do
        -- –≠—Ç–æ—Ç –∫–æ–¥ –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç. –ü–æ—á–µ–º—É?
        --if attack_rect.y < Hitbox.rect_of(self).y - 2 then
        --    flip = flip + 2
        --end
    end

    self.sprite:draw(tx, ty, flip)
    self.sprite:next_frame()

    if self.attack_effect_time > 0 then
        self.attack_effect:draw()
    end

    if self.is_dead then
        self.hat:draw()
    end

    --for _, attack_rect in ipairs(self.attack_rects) do
    --    attack_rect:draw()
    --end
end

Player.__index = Player
